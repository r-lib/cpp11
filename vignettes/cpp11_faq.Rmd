---
title: "cpp11 FAQ"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{cpp11 FAQ}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Intended to answer common questions about the usage of cpp11 objects

## FAQ

* What are the underlying types of cpp11 objects?

    vector   | element
    ---      | ---
    integers |	int
    doubles	 | double
    logicals | r_bool
    strings	 | r_string
    raws	   | uint8_t
    list	   | SEXP

* How do I create a new empty list?

    `cpp11::writable::list x;`

* How do I retrieve (named) elements from a named vector/list?

    `x["foo"]`

* How can I tell whether a vector is named?

    `x.names() == R_NilValue;`

* What are the types for C++ iterators?

  * Iterators are internal classes. An example of an iterator for
  doubles would be `cpp11::doubles::iterator`
  
* How do I return cpp11::writable::logicals() objects?
  
  * Use brace initialization:
  
    ```
    cpp11::cpp_function(code = '
      cpp11::writable::logicals fn2() {
        return {false};
      }')
    fn2()
    #> FALSE
    ```
    
  * Otherwise this will return a 0 length logical vector:
    
    ```
    cpp11::cpp_function(code = '
      cpp11::writable::logicals fn() {
        return false;
      }')
    fn()
    #> logical(0)
    ```
    
* Does cpp11 support default arguments?

  * cpp11 does not support default arguments at this time. Instead cpp11 registered functions can be wrapped in an R function for default argument support
  
  ```
  cpp11::cpp_function(code = '
       std::string fn(bool length) {
        if(length) {
          return ("length");
        }
        return ("width");
      }')


  full_fn <- function(length = FALSE) {
    fn(length)
  }
  full_fn(TRUE)
  #> "length"
  full_fn()
  #> "width"

  ```
  
  * Why do I have to 
  





