---
title: "cpp11 FAQ"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{cpp11 FAQ}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Intended to answer common questions about the usage of cpp11 objects

## FAQ

* How do I modify a vector in place?

  * Using `writable::` will always make a copy, but it has a move constructor, so you can use `cpp11::writable::integers(std::move(x))` and it won't make a copy of the data.

* How do I add elements to a named list?

* How do I create a new empty environment?

* What happens if I try to get a value that doesn't exist?

* How can I create a `cpp11:raws` from a `std::string`?

* What are the differences between `cpp11::sexp` and `SEXP`?

* What are the underlying types of cpp11 objects?

    vector   | element
    ---      | ---
    integers |	int
    doubles	 | double
    logicals | r_bool
    strings	 | r_string
    raws	   | uint8_t
    list	   | SEXP

* How do I create a new empty list?

    `cpp11::writable::list x;`

* How do I retrieve (named) elements from a named vector/list?

    `x["foo"]`

* How can I tell whether a vector is named?

    `x.names() == R_NilValue;`

* What are the types for C++ iterators?

  * Iterators are internal classes. An example of an iterator for
  doubles would be `cpp11::doubles::iterator`
  
* How do I return cpp11::writable::logicals() objects?
  
  * Use brace initialization:
  
    ```
    cpp11::cpp_function(code = '
      cpp11::writable::logicals fn2() {
        return {false};
      }')
    fn2()
    #> FALSE
    ```
    
  * Otherwise this will return a 0 length logical vector:
    
    ```
    cpp11::cpp_function(code = '
      cpp11::writable::logicals fn() {
        return false;
      }')
    fn()
    #> logical(0)
    ```
    
* Does cpp11 support default arguments?

  * cpp11 does not support default arguments at this time. Instead cpp11 registered functions can be wrapped in an R function for default argument support
  
  ```
  cpp11::cpp_function(code = '
       std::string fn(bool length) {
        if(length) {
          return ("length");
        }
        return ("width");
      }')


  full_fn <- function(length = FALSE) {
    fn(length)
  }
  full_fn(TRUE)
  #> "length"
  full_fn()
  #> "width"

  ```
  
  * Why do I have to include `using namespace` in my code as well as `std::` inside of `[[cpp11::register]]` functions?
  
    * Since namespace definitions will not be in the registration file generated by cpp11, types used in function definitions that are decorated with `[[cpp11::register]]` need to be fully qualified. However type names within those functions will work as expected.
    
    ```
    # This won't work because the return type is not fully qualified
    cpp11::cpp_source(code = '#include <cpp11.hpp>\n#include <string>

    using namespace std;

    [[cpp11::register]]
    string foobar() {
      return string("foo") + "-bar";
    }
    ')

    # However this will
    cpp11::cpp_source(code = '#include <cpp11.hpp>\n#include <string>

    using namespace std;

    [[cpp11::register]]
    std::string foobar() {
      return string("foo") + "-bar";
    }
    ')
    ```





