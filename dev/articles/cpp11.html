<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Get started with cpp11 • cpp11</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.9/font.css" rel="stylesheet">
<link href="../deps/Source_Code_Pro-0.4.9/font.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Get started with cpp11">
<meta name="robots" content="noindex">
<script defer data-domain="cpp11.r-lib.org,all.tidyverse.org" src="https://plausible.io/js/plausible.js"></script>
</head>
<body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="default" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">cpp11</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">0.4.7.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html">Home</a></li>
<li class="active nav-item"><a class="nav-link" href="../articles/cpp11.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/motivations.html">Motivations</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/converting.html">Converting</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/FAQ.html">FAQ</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/internals.html">Internals</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-news" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">News</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-news">
<li><a class="dropdown-item" href="../news/index.html">Change log</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-lib/cpp11/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article" id="container">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Get started with cpp11</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/r-lib/cpp11/blob/main/vignettes/cpp11.Rmd" class="external-link"><code>vignettes/cpp11.Rmd</code></a></small>
      <div class="d-none name"><code>cpp11.Rmd</code></div>
    </div>

    
    
<p><em>This content is adapted (with permission) from the <a href="https://adv-r.hadley.nz/rcpp.html" class="external-link">Rcpp chapter</a> of Hadley
Wickham’s book Advanced R.</em></p>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Sometimes R code just isn’t fast enough. You’ve used profiling to
figure out where your bottlenecks are, and you’ve done everything you
can in R, but your code still isn’t fast enough. In this vignette you’ll
learn how to improve performance by rewriting key functions in C++. This
magic comes by way of the <a href="https://github.com/r-lib/cpp11" class="external-link">cpp11</a> package.</p>
<p>cpp11 makes it very simple to connect C++ to R. While it is
<em>possible</em> to write C or Fortran code for use in R, it will be
painful by comparison. cpp11 provides a clean, approachable API that
lets you write high-performance code, insulated from R’s more complex C
API.</p>
<p>Typical bottlenecks that C++ can address include:</p>
<ul>
<li><p>Loops that can’t be easily vectorised because subsequent
iterations depend on previous ones.</p></li>
<li><p>Recursive functions, or problems which involve calling functions
millions of times. The overhead of calling a function in C++ is much
lower than in R.</p></li>
<li><p>Problems that require advanced data structures and algorithms
that R doesn’t provide. Through the standard template library (STL), C++
has efficient implementations of many important data structures, from
ordered maps to double-ended queues.</p></li>
</ul>
<p>The aim of this vignette is to discuss only those aspects of C++ and
cpp11 that are absolutely necessary to help you eliminate bottlenecks in
your code. We won’t spend much time on advanced features like
object-oriented programming or templates because the focus is on writing
small, self-contained functions, not big programs. A working knowledge
of C++ is helpful, but not essential. Many good tutorials and references
are freely available, including <a href="https://www.learncpp.com/" class="external-link uri">https://www.learncpp.com/</a> and <a href="https://en.cppreference.com/w/cpp" class="external-link uri">https://en.cppreference.com/w/cpp</a>. For more advanced
topics, the <em>Effective C++</em> series by Scott Meyers is a popular
choice.</p>
<div class="section level3">
<h3 id="outline">Outline<a class="anchor" aria-label="anchor" href="#outline"></a>
</h3>
<ul>
<li><p>Section <a href="#intro">intro</a> teaches you how to write C++
by converting simple R functions to their C++ equivalents. You’ll learn
how C++ differs from R, and what the key scalar, vector, and matrix
classes are called.</p></li>
<li><p>Section <a href="#cpp-source">cpp_source</a> shows you how to use
<code><a href="../reference/cpp_source.html">cpp11::cpp_source()</a></code> to load a C++ file from disk in the
same way you use <code><a href="https://rdrr.io/r/base/source.html" class="external-link">source()</a></code> to load a file of R
code.</p></li>
<li><p>Section <a href="#classes">classes</a> discusses how to modify
attributes from cpp11, and mentions some of the other important
classes.</p></li>
<li><p>Section <a href="#na">na</a> teaches you how to work with R’s
missing values in C++.</p></li>
<li><p>Section <a href="#stl">stl</a> shows you how to use some of the
most important data structures and algorithms from the standard template
library, or STL, built-in to C++.</p></li>
<li><p>Section <a href="#case-studies">case-studies</a> shows two real
case studies where cpp11 was used to get considerable performance
improvements.</p></li>
<li><p>Section <a href="#package">package</a> teaches you how to add C++
code to an R package.</p></li>
<li><p>Section <a href="#more">more</a> concludes the vignette with
pointers to more resources to help you learn cpp11 and C++.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="prerequisites">Prerequisites<a class="anchor" aria-label="anchor" href="#prerequisites"></a>
</h3>
<p>We’ll use <a href="https://github.com/r-lib/cpp11" class="external-link">cpp11</a> to call
C++ from R:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://cpp11.r-lib.org">cpp11</a></span><span class="op">)</span></span></code></pre></div>
<p>You’ll also need a working C++ compiler. To get it:</p>
<ul>
<li>On Windows, install <a href="https://cran.r-project.org/bin/windows/Rtools/" class="external-link">Rtools</a>.</li>
<li>On Mac, install Xcode from the app store.</li>
<li>On Linux, <code>sudo apt-get install r-base-dev</code> or
similar.</li>
</ul>
</div>
</div>
<div class="section level2">
<h2 id="intro">Getting started with C++<a class="anchor" aria-label="anchor" href="#intro"></a>
</h2>
<p><code><a href="../reference/cpp_source.html">cpp_function()</a></code> allows you to write C++ functions in
R:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/cpp_source.html">cpp_function</a></span><span class="op">(</span><span class="st">'int add(int x, int y, int z) {</span></span>
<span><span class="st">  int sum = x + y + z;</span></span>
<span><span class="st">  return sum;</span></span>
<span><span class="st">}'</span><span class="op">)</span></span>
<span><span class="co"># add works like a regular R function</span></span>
<span><span class="va">add</span></span>
<span><span class="co">#&gt; function (x, y, z) </span></span>
<span><span class="co">#&gt; {</span></span>
<span><span class="co">#&gt;     .Call("_code_19bbb690706_add", x, y, z, PACKAGE = "code_19bbb690706")</span></span>
<span><span class="co">#&gt; }</span></span>
<span><span class="fu">add</span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 6</span></span></code></pre></div>
<p>When you run the above code, cpp11 will compile the C++ code and
construct an R function that connects to the compiled C++ function.
There’s a lot going on underneath the hood but cpp11 takes care of all
the details so you don’t need to worry about them.</p>
<p>The following sections will teach you the basics by translating
simple R functions to their C++ equivalents. We’ll start simple with a
function that has no inputs and a scalar output, and then make it
progressively more complicated:</p>
<ul>
<li>Scalar input and scalar output</li>
<li>Vector input and scalar output</li>
<li>Vector input and vector output</li>
<li>Matrix input and vector output</li>
</ul>
<div class="section level3">
<h3 id="no-inputs-scalar-output">No inputs, scalar output<a class="anchor" aria-label="anchor" href="#no-inputs-scalar-output"></a>
</h3>
<p>Let’s start with a very simple function. It has no arguments and
always returns the integer 1:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">one</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="fl">1L</span></span></code></pre></div>
<p>The equivalent C++ function is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="dt">int</span> one<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can compile and use this from R with
<code><a href="../reference/cpp_source.html">cpp_function()</a></code></p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/cpp_source.html">cpp_function</a></span><span class="op">(</span><span class="st">'int one() {</span></span>
<span><span class="st">  return 1;</span></span>
<span><span class="st">}'</span><span class="op">)</span></span></code></pre></div>
<p>This small function illustrates a number of important differences
between R and C++:</p>
<ul>
<li><p>The syntax to create a function looks like the syntax to call a
function; you don’t use assignment to create functions as you do in
R.</p></li>
<li><p>You must declare the type of output the function returns. This
function returns an <code>int</code> (a scalar integer). The classes for
the most common types of R vectors are: <code>doubles</code>,
<code>integers</code>, <code>strings</code>, and
<code>logicals</code>.</p></li>
<li><p>Scalars and vectors are different. The scalar equivalents of
numeric, integer, character, and logical vectors are:
<code>double</code>, <code>int</code>, <code>String</code>, and
<code>bool</code>.</p></li>
<li><p>You must use an explicit <code>return</code> statement to return
a value from a function.</p></li>
<li><p>Every statement is terminated by a <code>;</code>.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="scalar-input-scalar-output">Scalar input, scalar output<a class="anchor" aria-label="anchor" href="#scalar-input-scalar-output"></a>
</h3>
<p>The next example function implements a scalar version of the
<code><a href="https://rdrr.io/r/base/sign.html" class="external-link">sign()</a></code> function which returns 1 if the input is positive,
and -1 if it’s negative:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sign_r</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">x</span> <span class="op">&gt;</span> <span class="fl">0</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fl">1</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="va">x</span> <span class="op">==</span> <span class="fl">0</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="fl">0</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span>    <span class="op">-</span><span class="fl">1</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="../reference/cpp_source.html">cpp_function</a></span><span class="op">(</span><span class="st">'int sign_cpp(int x) {</span></span>
<span><span class="st">  if (x &gt; 0) {</span></span>
<span><span class="st">    return 1;</span></span>
<span><span class="st">  } else if (x == 0) {</span></span>
<span><span class="st">    return 0;</span></span>
<span><span class="st">  } else {</span></span>
<span><span class="st">    return -1;</span></span>
<span><span class="st">  }</span></span>
<span><span class="st">}'</span><span class="op">)</span></span></code></pre></div>
<p>In the C++ version:</p>
<ul>
<li><p>We declare the type of each input in the same way we declare the
type of the output. While this makes the code a little more verbose, it
also makes clear the type of input the function needs.</p></li>
<li><p>The <code>if</code> syntax is identical — while there are some
big differences between R and C++, there are also lots of similarities!
C++ also has a <code>while</code> statement that works the same way as
R’s. As in R you can use <code><a href="https://rdrr.io/r/base/Control.html" class="external-link">break</a></code> to exit the loop, but to
skip one iteration you need to use <code>continue</code> instead of
<code><a href="https://rdrr.io/r/base/Control.html" class="external-link">next</a></code>.</p></li>
</ul>
</div>
<div class="section level3">
<h3 id="vector-input-scalar-output">Vector input, scalar output<a class="anchor" aria-label="anchor" href="#vector-input-scalar-output"></a>
</h3>
<p>One big difference between R and C++ is that the cost of loops is
much lower in C++. For example, we could implement the <code>sum</code>
function in R using a loop. If you’ve been programming in R a while,
you’ll probably have a visceral reaction to this function!</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sum_r</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">total</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">total</span> <span class="op">&lt;-</span> <span class="va">total</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="va">i</span><span class="op">]</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="va">total</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>In C++, loops have very little overhead, so it’s fine to use them. In
Section <a href="#stl">stl</a>, you’ll see alternatives to
<code>for</code> loops that more clearly express your intent; they’re
not faster, but they can make your code easier to understand.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/cpp_source.html">cpp_function</a></span><span class="op">(</span><span class="st">'double sum_cpp(doubles x) {</span></span>
<span><span class="st">  int n = x.size();</span></span>
<span><span class="st">  double total = 0;</span></span>
<span><span class="st">  for(int i = 0; i &lt; n; ++i) {</span></span>
<span><span class="st">    total += x[i];</span></span>
<span><span class="st">  }</span></span>
<span><span class="st">  return total;</span></span>
<span><span class="st">}'</span><span class="op">)</span></span></code></pre></div>
<p>The C++ version is similar, but:</p>
<ul>
<li><p>To find the length of the vector, we use the <code>.size()</code>
method, which returns an integer. C++ methods are called with
<code>.</code> (i.e., a full stop).</p></li>
<li><p>The <code>for</code> statement has a different syntax:
<code>for(init; check; increment)</code>. This loop is initialised by
creating a new variable called <code>i</code> with value 0. Before each
iteration we check that <code>i &lt; n</code>, and terminate the loop if
it’s not. After each iteration, we increment the value of <code>i</code>
by one, using the special prefix operator <code>++</code> which
increases the value of <code>i</code> by 1.</p></li>
<li><p>In C++, vector indices start at 0, which means that the last
element is at position <code>n - 1</code>. I’ll say this again because
it’s so important: <strong>IN C++, VECTOR INDICES START AT 0</strong>!
This is a very common source of bugs when converting R functions to
C++.</p></li>
<li><p>Use <code>=</code> for assignment, not
<code>&lt;-</code>.</p></li>
<li><p>C++ provides operators that modify in-place:
<code>total += x[i]</code> is equivalent to
<code>total = total + x[i]</code>. Similar in-place operators are
<code>-=</code>, <code>*=</code>, and <code>/=</code>.</p></li>
</ul>
<p>This is a good example of where C++ is much more efficient than R. As
shown by the following microbenchmark, <code>sum_cpp()</code> is
competitive with the built-in (and highly optimised) <code><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum()</a></code>,
while <code>sum_r()</code> is several orders of magnitude slower.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1e3</span><span class="op">)</span></span>
<span><span class="fu">bench</span><span class="fu">::</span><span class="fu"><a href="http://bench.r-lib.org/reference/mark.html" class="external-link">mark</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span>,</span>
<span>  <span class="fu">sum_cpp</span><span class="op">(</span><span class="va">x</span><span class="op">)</span>,</span>
<span>  <span class="fu">sum_r</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 3 × 6</span></span></span>
<span><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span><span class="co">#&gt;   <span style="color: #949494; font-style: italic;">&lt;bch:expr&gt;</span> <span style="color: #949494; font-style: italic;">&lt;bch:tm&gt;</span> <span style="color: #949494; font-style: italic;">&lt;bch:tm&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;bch:byt&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">1</span> sum(x)       2.06µs   2.09µs   <span style="text-decoration: underline;">440</span>369.        0B        0</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">2</span> sum_cpp(x)   2.05µs   2.17µs   <span style="text-decoration: underline;">402</span>564.        0B        0</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">3</span> sum_r(x)    20.09µs  20.63µs    <span style="text-decoration: underline;">47</span>930.    35.7KB        0</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="vector-input-vector-output">Vector input, vector output<a class="anchor" aria-label="anchor" href="#vector-input-vector-output"></a>
</h3>
<!-- FIXME: come up with better example. Also fix in two other places it occurs -->
<p>Next we’ll create a function that computes the Euclidean distance
between a value and a vector of values:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pdist_r</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span>, <span class="va">ys</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="op">(</span><span class="va">x</span> <span class="op">-</span> <span class="va">ys</span><span class="op">)</span> <span class="op">^</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>In R, it’s not obvious that we want <code>x</code> to be a scalar
from the function definition, and we’d need to make that clear in the
documentation. That’s not a problem in the C++ version because we have
to be explicit about types:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/cpp_source.html">cpp_function</a></span><span class="op">(</span><span class="st">'doubles pdist_cpp(double x, doubles ys) {</span></span>
<span><span class="st">  int n = ys.size();</span></span>
<span><span class="st">  writable::doubles out(n);</span></span>
<span><span class="st">  for(int i = 0; i &lt; n; ++i) {</span></span>
<span><span class="st">    out[i] = sqrt(pow(ys[i] - x, 2.0));</span></span>
<span><span class="st">  }</span></span>
<span><span class="st">  return out;</span></span>
<span><span class="st">}'</span><span class="op">)</span></span></code></pre></div>
<p>This function introduces a few new concepts:</p>
<ul>
<li><p>Because we are creating a new vector we need to use
<code>writable::doubles</code> rather than the read-only
<code>doubles</code>.</p></li>
<li><p>We create a new numeric vector of length <code>n</code> with a
constructor: <code>cpp11::writable::doubles out(n)</code>. Another
useful way of making a vector is to copy an existing one:
<code>cpp11::doubles zs(ys)</code>.</p></li>
<li><p>C++ uses <code>pow()</code>, not <code>^</code>, for
exponentiation.</p></li>
</ul>
<p>Note that because the R version is fully vectorised, it’s already
going to be fast.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">1e6</span><span class="op">)</span></span>
<span><span class="fu">bench</span><span class="fu">::</span><span class="fu"><a href="http://bench.r-lib.org/reference/mark.html" class="external-link">mark</a></span><span class="op">(</span></span>
<span>  <span class="fu">pdist_r</span><span class="op">(</span><span class="fl">0.5</span>, <span class="va">y</span><span class="op">)</span>,</span>
<span>  <span class="fu">pdist_cpp</span><span class="op">(</span><span class="fl">0.5</span>, <span class="va">y</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">]</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 2 × 6</span></span></span>
<span><span class="co">#&gt;   expression             min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span><span class="co">#&gt;   <span style="color: #949494; font-style: italic;">&lt;bch:expr&gt;</span>        <span style="color: #949494; font-style: italic;">&lt;bch:tm&gt;</span> <span style="color: #949494; font-style: italic;">&lt;bch:tm&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;bch:byt&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">1</span> pdist_r(0.5, y)     5.02ms   5.55ms      177.    7.63MB     90.4</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">2</span> pdist_cpp(0.5, y)    3.9ms    4.3ms      236.    7.63MB    114.</span></span></code></pre></div>
<p>On my computer, it takes around 5 ms with a 1 million element
<code>y</code> vector. The C++ function is about 2.5 times faster, ~2
ms, but assuming it took you 10 minutes to write the C++ function, you’d
need to run it ~200,000 times to make rewriting worthwhile. The reason
why the C++ function is faster is subtle, and relates to memory
management. The R version needs to create an intermediate vector the
same length as y (<code>x - ys</code>), and allocating memory is an
expensive operation. The C++ function avoids this overhead because it
uses an intermediate scalar.</p>
</div>
<div class="section level3">
<h3 id="cpp-source">Using cpp_source<a class="anchor" aria-label="anchor" href="#cpp-source"></a>
</h3>
<p>So far, we’ve used inline C++ with <code><a href="../reference/cpp_source.html">cpp_function()</a></code>. This
makes presentation simpler, but for real problems, it’s usually easier
to use stand-alone C++ files and then source them into R using
<code><a href="../reference/cpp_source.html">cpp_source()</a></code>. This lets you take advantage of text editor
support for C++ files (e.g., syntax highlighting) as well as making it
easier to identify the line numbers in compilation errors.</p>
<p>Your stand-alone C++ file should have extension <code>.cpp</code>,
and needs to start with:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span></code></pre></div>
<p>And for each function that you want available within R, you need to
prefix it with:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span></code></pre></div>
<p>If you’re familiar with roxygen2, you might wonder how this relates
to <code>@export</code>. <code>cpp11::register</code> registers a C++
function to be called from R. <code>@export</code> controls whether a
function is exported from a package and made available to the user.</p>
<p>To compile the C++ code, use
<code>cpp_source("path/to/file.cpp")</code>. This will create the
matching R functions and add them to your current session. Note that
these functions can not be saved in a <code>.Rdata</code> file and
reloaded in a later session; they must be recreated each time you
restart R.</p>
<p>This example also illustrates a different kind of a <code>for</code>
loop, a for-each loop.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11/doubles.hpp"</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="dt">double</span> mean_cpp<span class="op">(</span>doubles x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> x<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>  <span class="dt">double</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">double</span> value <span class="op">:</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>    total <span class="op">+=</span> value<span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>  <span class="cf">return</span> total <span class="op">/</span> n<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>NB: if you run this code, you’ll notice that <code>mean_cpp()</code>
is faster than the built-in <code><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean()</a></code>. This is because it
trades numerical accuracy for speed.</p>
<p>For the remainder of this vignette C++ code will be presented
stand-alone rather than wrapped in a call to <code>cpp_function</code>.
If you want to try compiling and/or modifying the examples you should
paste them into a C++ source file that includes the elements described
above. This is easy to do in RMarkdown by using <a href="https://cpp11.r-lib.org">cpp11</a>
instead of <code>{r}</code> at the beginning of your code blocks.</p>
</div>
<div class="section level3">
<h3 id="exercises">Exercises<a class="anchor" aria-label="anchor" href="#exercises"></a>
</h3>
<ol style="list-style-type: decimal">
<li>With the basics of C++ in hand, it’s now a great time to practice by
reading and writing some simple C++ functions. For each of the following
functions, read the code and figure out what the corresponding base R
function is. You might not understand every part of the code yet, but
you should be able to figure out the basics of what the function
does.</li>
</ol>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="kw">namespace</span> writable <span class="op">=</span> cpp11<span class="op">::</span>writable<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a><span class="dt">double</span> f1<span class="op">(</span>doubles x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> x<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>  <span class="dt">double</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" tabindex="-1"></a></span>
<span id="cb16-11"><a href="#cb16-11" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12" tabindex="-1"></a>    y <span class="op">+=</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">/</span> n<span class="op">;</span></span>
<span id="cb16-13"><a href="#cb16-13" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-14"><a href="#cb16-14" tabindex="-1"></a>  <span class="cf">return</span> y<span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-16"><a href="#cb16-16" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb16-18"><a href="#cb16-18" tabindex="-1"></a>doubles f2<span class="op">(</span>doubles x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-19"><a href="#cb16-19" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> x<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb16-20"><a href="#cb16-20" tabindex="-1"></a>  writable<span class="op">::</span>doubles out<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb16-21"><a href="#cb16-21" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" tabindex="-1"></a>  out<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> x<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb16-23"><a href="#cb16-23" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-24"><a href="#cb16-24" tabindex="-1"></a>    out<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> out<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> x<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb16-25"><a href="#cb16-25" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-26"><a href="#cb16-26" tabindex="-1"></a>  <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb16-27"><a href="#cb16-27" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-28"><a href="#cb16-28" tabindex="-1"></a></span>
<span id="cb16-29"><a href="#cb16-29" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb16-30"><a href="#cb16-30" tabindex="-1"></a><span class="dt">bool</span> f3<span class="op">(</span>logicals x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-31"><a href="#cb16-31" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> x<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb16-32"><a href="#cb16-32" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-34"><a href="#cb16-34" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb16-35"><a href="#cb16-35" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb16-36"><a href="#cb16-36" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-37"><a href="#cb16-37" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-38"><a href="#cb16-38" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb16-39"><a href="#cb16-39" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-40"><a href="#cb16-40" tabindex="-1"></a></span>
<span id="cb16-41"><a href="#cb16-41" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb16-42"><a href="#cb16-42" tabindex="-1"></a><span class="dt">int</span> f4<span class="op">(</span>cpp11<span class="op">::</span>function pred<span class="op">,</span> list x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-43"><a href="#cb16-43" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> x<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb16-44"><a href="#cb16-44" tabindex="-1"></a></span>
<span id="cb16-45"><a href="#cb16-45" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-46"><a href="#cb16-46" tabindex="-1"></a>    logicals res<span class="op">(</span>pred<span class="op">(</span>x<span class="op">[</span>i<span class="op">]));</span></span>
<span id="cb16-47"><a href="#cb16-47" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>res<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb16-48"><a href="#cb16-48" tabindex="-1"></a>      <span class="cf">return</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-49"><a href="#cb16-49" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-50"><a href="#cb16-50" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb16-51"><a href="#cb16-51" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-52"><a href="#cb16-52" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol style="list-style-type: decimal">
<li>
<p>To practice your function writing skills, convert the following
functions into C++. For now, assume the inputs have no missing
values.</p>
<ol style="list-style-type: decimal">
<li><p><code><a href="https://rdrr.io/r/base/all.html" class="external-link">all()</a></code>.</p></li>
<li><p><code><a href="https://rdrr.io/r/base/cumsum.html" class="external-link">cumprod()</a></code>, <code><a href="https://rdrr.io/r/base/cumsum.html" class="external-link">cummin()</a></code>,
<code><a href="https://rdrr.io/r/base/cumsum.html" class="external-link">cummax()</a></code>.</p></li>
<li><p><code><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff()</a></code>. Start by assuming lag 1, and then generalise
for lag <code>n</code>.</p></li>
<li><p><code><a href="https://rdrr.io/r/base/range.html" class="external-link">range()</a></code>.</p></li>
<li><p><code><a href="https://rdrr.io/r/stats/cor.html" class="external-link">var()</a></code>. Read about the approaches you can take on <a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance" class="external-link">Wikipedia</a>.
Whenever implementing a numerical algorithm, it’s always good to check
what is already known about the problem.</p></li>
</ol>
</li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="classes">Other classes<a class="anchor" aria-label="anchor" href="#classes"></a>
</h2>
<p>You’ve already seen the basic vector classes (<code>integers</code>,
<code>doubles</code>, <code>logicals</code>, <code>strings</code>) and
their scalar (<code>int</code>, <code>double</code>, <code>bool</code>,
<code>string</code>) equivalents. cpp11 also provides wrappers for other
base data types. The most important are for lists and data frames,
functions, and attributes, as described below.</p>
<div class="section level3">
<h3 id="lists-and-data-frames">Lists and data frames<a class="anchor" aria-label="anchor" href="#lists-and-data-frames"></a>
</h3>
<p>cpp11 also provides <code>list</code> and <code>data_frame</code>
classes, but they are more useful for output than input. This is because
lists and data frames can contain arbitrary classes but C++ needs to
know their classes in advance. If the list has known structure (e.g.,
it’s an S3 object), you can extract the components and manually convert
them to their C++ equivalents with <code>as_cpp()</code>. For example,
the object created by <code><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm()</a></code>, the function that fits a linear
model, is a list whose components are always of the same type.</p>
<p>The following code illustrates how you might extract the mean
percentage error (<code>mpe()</code>) of a linear model. This isn’t a
good example of when to use C++, because it’s so easily implemented in
R, but it shows how to work with an important S3 class. Note the use of
<code>Rf_inherits()</code> and the <code><a href="https://rdrr.io/r/base/stop.html" class="external-link">stop()</a></code> to check that the
object really is a linear model.</p>
<!-- FIXME: needs better motivation -->
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a><span class="dt">double</span> mpe<span class="op">(</span>list mod<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>Rf_inherits<span class="op">(</span>mod<span class="op">,</span> <span class="st">"lm"</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>    stop<span class="op">(</span><span class="st">"Input must be a linear model"</span><span class="op">);</span></span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a>  doubles resid<span class="op">(</span>mod<span class="op">[</span><span class="st">"residuals"</span><span class="op">]);</span></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>  doubles fitted<span class="op">(</span>mod<span class="op">[</span><span class="st">"fitted.values"</span><span class="op">]);</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> resid<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a>  <span class="dt">double</span> err <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-14"><a href="#cb17-14" tabindex="-1"></a>    err <span class="op">+=</span> resid<span class="op">[</span>i<span class="op">]</span> <span class="op">/</span> <span class="op">(</span>fitted<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> resid<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb17-15"><a href="#cb17-15" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb17-16"><a href="#cb17-16" tabindex="-1"></a>  <span class="cf">return</span> err <span class="op">/</span> n<span class="op">;</span></span>
<span id="cb17-17"><a href="#cb17-17" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mod</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html" class="external-link">lm</a></span><span class="op">(</span><span class="va">mpg</span> <span class="op">~</span> <span class="va">wt</span>, data <span class="op">=</span> <span class="va">mtcars</span><span class="op">)</span></span>
<span><span class="fu">mpe</span><span class="op">(</span><span class="va">mod</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] -0.01541615</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="functions-cpp11">Functions<a class="anchor" aria-label="anchor" href="#functions-cpp11"></a>
</h3>
<p>You can put R functions in an object of type <code>function</code>.
This makes calling an R function from C++ straightforward. The only
challenge is that we don’t know what type of output the function will
return, so we use the catchall type <code>sexp</code>. This stands for
S-Expression and is used as the type of all R Objects in the internal C
code.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="kw">namespace</span> writable <span class="op">=</span> cpp11<span class="op">::</span>writable<span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a>sexp call_with_one<span class="op">(</span>function f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a>  <span class="cf">return</span> f<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">call_with_one</span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="va">x</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 2</span></span>
<span><span class="fu">call_with_one</span><span class="op">(</span><span class="va">paste</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "1"</span></span></code></pre></div>
<p>Calling R functions with positional arguments is obvious:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>f<span class="op">(</span><span class="st">"y"</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>But you need a special syntax for named arguments:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">::</span>literals<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>f<span class="op">(</span><span class="st">"x"</span><span class="op">_nm</span> <span class="op">=</span> <span class="st">"y"</span><span class="op">,</span> <span class="st">"value"</span><span class="op">_nm</span> <span class="op">=</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="attributes">Attributes<a class="anchor" aria-label="anchor" href="#attributes"></a>
</h3>
<p>All R objects have attributes, which can be queried and modified with
<code>.attr()</code>. cpp11 also provides <code>.names()</code> as an
alias for the <code>names</code> attribute. The following code snippet
illustrates these methods. Note the use of <code><a href="https://rdrr.io/r/base/Paren.html" class="external-link">{}</a></code> <a href="https://en.cppreference.com/w/cpp/utility/initializer_list" class="external-link">initializer
list</a> syntax. This allows you to create an R vector from C++ scalar
values:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="kw">namespace</span> writable <span class="op">=</span> cpp11<span class="op">::</span>writable<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>doubles attribs<span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>  writable<span class="op">::</span>doubles out <span class="op">=</span> <span class="op">{</span><span class="fl">1.</span><span class="op">,</span> <span class="fl">2.</span><span class="op">,</span> <span class="fl">3.</span><span class="op">};</span></span>
<span id="cb23-8"><a href="#cb23-8" tabindex="-1"></a>  out<span class="op">.</span>names<span class="op">()</span> <span class="op">=</span> <span class="op">{</span><span class="st">"a"</span><span class="op">,</span> <span class="st">"b"</span><span class="op">,</span> <span class="st">"c"</span><span class="op">};</span></span>
<span id="cb23-9"><a href="#cb23-9" tabindex="-1"></a>  out<span class="op">.</span>attr<span class="op">(</span><span class="st">"my-attr"</span><span class="op">)</span> <span class="op">=</span> <span class="st">"my-value"</span><span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" tabindex="-1"></a>  out<span class="op">.</span>attr<span class="op">(</span><span class="st">"class"</span><span class="op">)</span> <span class="op">=</span> <span class="st">"my-class"</span><span class="op">;</span></span>
<span id="cb23-11"><a href="#cb23-11" tabindex="-1"></a>  <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb23-12"><a href="#cb23-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="na">Missing values<a class="anchor" aria-label="anchor" href="#na"></a>
</h2>
<p>If you’re working with missing values, you need to know two
things:</p>
<ul>
<li><p>How R’s missing values behave in C++’s scalars (e.g.,
<code>double</code>).</p></li>
<li><p>How to get and set missing values in vectors (e.g.,
<code>doubles</code>).</p></li>
</ul>
<div class="section level3">
<h3 id="scalars">Scalars<a class="anchor" aria-label="anchor" href="#scalars"></a>
</h3>
<p>The following code explores what happens when you take one of R’s
missing values, coerce it into a scalar, and then coerce back to an R
vector. Note that this kind of experimentation is a useful way to figure
out what any operation does.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a>list scalar_missings<span class="op">()</span> <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>  <span class="dt">int</span> int_s <span class="op">=</span> NA_INTEGER<span class="op">;</span></span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>  r_string chr_s <span class="op">=</span> NA_STRING<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>  <span class="dt">bool</span> lgl_s <span class="op">=</span> NA_LOGICAL<span class="op">;</span></span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a>  <span class="dt">double</span> num_s <span class="op">=</span> NA_REAL<span class="op">;</span></span>
<span id="cb24-10"><a href="#cb24-10" tabindex="-1"></a>  <span class="cf">return</span> writable<span class="op">::</span>list<span class="op">({</span>as_sexp<span class="op">(</span>int_s<span class="op">),</span> as_sexp<span class="op">(</span>chr_s<span class="op">),</span> as_sexp<span class="op">(</span>lgl_s<span class="op">),</span> as_sexp<span class="op">(</span>num_s<span class="op">)});</span></span>
<span id="cb24-11"><a href="#cb24-11" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="fu">scalar_missings</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; List of 4</span></span>
<span><span class="co">#&gt;  $ : int NA</span></span>
<span><span class="co">#&gt;  $ : chr NA</span></span>
<span><span class="co">#&gt;  $ : logi TRUE</span></span>
<span><span class="co">#&gt;  $ : num NA</span></span></code></pre></div>
<p>With the exception of <code>bool</code>, things look pretty good
here: all of the missing values have been preserved. However, as we’ll
see in the following sections, things are not quite as straightforward
as they seem.</p>
<div class="section level4">
<h4 id="integers">Integers<a class="anchor" aria-label="anchor" href="#integers"></a>
</h4>
<p>With integers, missing values are stored as the smallest integer. If
you don’t do anything to them, they’ll be preserved. But, since C++
doesn’t know that the smallest integer has this special behaviour, if
you do anything to it you’re likely to get an incorrect value: for
example, <code>cpp_eval('NA_INTEGER + 1')</code> gives -2147483647.</p>
<p>So if you want to work with missing values in integers, either use a
length 1 <code>integers</code> or be very careful with your code.</p>
</div>
<div class="section level4">
<h4 id="doubles">Doubles<a class="anchor" aria-label="anchor" href="#doubles"></a>
</h4>
<p>With doubles, you may be able to get away with ignoring missing
values and working with NaNs (not a number). This is because R’s NA is a
special type of IEEE 754 floating point number NaN. So any logical
expression that involves a NaN (or in C++, NAN) always evaluates as
FALSE:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN == 1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN &lt; 1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN &gt; 1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span>
<span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN == NAN"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span></code></pre></div>
<p>(Here I’m using <code><a href="../reference/cpp_source.html">cpp_eval()</a></code> which allows you to see the
result of running a single C++ expression, making it excellent for this
sort of interactive experimentation.) But be careful when combining them
with Boolean values:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN &amp;&amp; TRUE"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span>
<span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN || FALSE"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>However, in numeric contexts NaNs will propagate NAs:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN + 1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] NaN</span></span>
<span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN - 1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] NaN</span></span>
<span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN / 1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] NaN</span></span>
<span><span class="fu"><a href="../reference/cpp_source.html">cpp_eval</a></span><span class="op">(</span><span class="st">"NAN * 1"</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] NaN</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="strings">Strings<a class="anchor" aria-label="anchor" href="#strings"></a>
</h3>
<p><code>String</code> is a scalar string class introduced by cpp11, so
it knows how to deal with missing values.</p>
</div>
<div class="section level3">
<h3 id="boolean">Boolean<a class="anchor" aria-label="anchor" href="#boolean"></a>
</h3>
<p>C++’s <code>bool</code> has two possible values (<code>true</code> or
<code>false</code>), a logical vector in R has three (<code>TRUE</code>,
<code>FALSE</code>, and <code>NA</code>). If you coerce a length 1
logical vector, make sure it doesn’t contain any missing values;
otherwise they will be converted to TRUE. One way to fix this is to use
<code>int</code> instead, as this can represent <code>TRUE</code>,
<code>FALSE</code>, and <code>NA</code>.</p>
</div>
<div class="section level3">
<h3 id="vectors-cpp11">Vectors<a class="anchor" aria-label="anchor" href="#vectors-cpp11"></a>
</h3>
<p>With vectors, you need to use a missing value specific to the type of
vector, <code>NA_REAL</code>, <code>NA_INTEGER</code>,
<code>NA_LOGICAL</code>, <code>NA_STRING</code>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a><span class="kw">namespace</span> writable <span class="op">=</span> cpp11<span class="op">::</span>writable<span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a>list missing_sampler<span class="op">()</span> <span class="op">{</span></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a>  <span class="cf">return</span> writable<span class="op">::</span>list<span class="op">({</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a>    writable<span class="op">::</span>doubles<span class="op">({</span>NA_REAL<span class="op">}),</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a>    writable<span class="op">::</span>integers<span class="op">({</span>NA_INTEGER<span class="op">}),</span></span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a>    writable<span class="op">::</span>logicals<span class="op">({</span>r_bool<span class="op">(</span>NA_LOGICAL<span class="op">)}),</span></span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a>    writable<span class="op">::</span>strings<span class="op">({</span>NA_STRING<span class="op">})</span></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a>  <span class="op">});</span></span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="fu">missing_sampler</span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; List of 4</span></span>
<span><span class="co">#&gt;  $ : num NA</span></span>
<span><span class="co">#&gt;  $ : int NA</span></span>
<span><span class="co">#&gt;  $ : logi NA</span></span>
<span><span class="co">#&gt;  $ : chr NA</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="exercises-1">Exercises<a class="anchor" aria-label="anchor" href="#exercises-1"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p>Rewrite any of the functions from the first exercise to deal with
missing values. If <code>na_rm</code> is true, ignore the missing
values. If <code>na_rm</code> is false, return a missing value if the
input contains any missing values. Some good functions to practice with
are <code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min()</a></code>, <code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max()</a></code>, <code><a href="https://rdrr.io/r/base/range.html" class="external-link">range()</a></code>,
<code><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean()</a></code>, and <code><a href="https://rdrr.io/r/stats/cor.html" class="external-link">var()</a></code>.</p></li>
<li><p>Rewrite <code><a href="https://rdrr.io/r/base/cumsum.html" class="external-link">cumsum()</a></code> and <code><a href="https://rdrr.io/r/base/diff.html" class="external-link">diff()</a></code> so they can
handle missing values. Note that these functions have slightly more
complicated behaviour.</p></li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="stl">Standard Template Library<a class="anchor" aria-label="anchor" href="#stl"></a>
</h2>
<p>The real strength of C++ is revealed when you need to implement more
complex algorithms. The standard template library (STL) provides a set
of extremely useful data structures and algorithms. This section will
explain some of the most important algorithms and data structures and
point you in the right direction to learn more. I can’t teach you
everything you need to know about the STL, but hopefully the examples
will show you the power of the STL, and persuade you that it’s useful to
learn more.</p>
<p>If you need an algorithm or data structure that isn’t implemented in
STL, one place to look is <a href="https://www.boost.org/doc/" class="external-link">boost</a>. Installing boost on your
computer is beyond the scope of this vignette, but once you have it
installed, you can use boost data structures and algorithms by including
the appropriate header file with (e.g.)
<code>#include &lt;boost/array.hpp&gt;</code>.</p>
<div class="section level3">
<h3 id="using-iterators">Using iterators<a class="anchor" aria-label="anchor" href="#using-iterators"></a>
</h3>
<p>Iterators are used extensively in the STL: many functions either
accept or return iterators. They are the next step up from basic loops,
abstracting away the details of the underlying data structure. Iterators
have three main operators:</p>
<ol style="list-style-type: decimal">
<li>Advance with <code>++</code>.</li>
<li>Get the value they refer to, or <strong>dereference</strong>, with
<code>*</code>.</li>
<li>Compare with <code>==</code>.</li>
</ol>
<p>For example we could re-write our sum function using iterators:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a><span class="dt">double</span> sum2<span class="op">(</span>doubles x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-6"><a href="#cb31-6" tabindex="-1"></a>  <span class="dt">double</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> x<span class="op">.</span>begin<span class="op">();</span> it <span class="op">!=</span> x<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-9"><a href="#cb31-9" tabindex="-1"></a>    total <span class="op">+=</span> <span class="op">*</span>it<span class="op">;</span></span>
<span id="cb31-10"><a href="#cb31-10" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb31-11"><a href="#cb31-11" tabindex="-1"></a>  <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb31-12"><a href="#cb31-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The main changes are in the for loop:</p>
<ul>
<li><p>We start at <code>x.begin()</code> and loop until we get to
<code>x.end()</code>. A small optimization is to store the value of the
end iterator so we don’t need to look it up each time. This only saves
about 2 ns per iteration, so it’s only important when the calculations
in the loop are very simple.</p></li>
<li><p>Instead of indexing into x, we use the dereference operator to
get its current value: <code>*it</code>.</p></li>
<li><p>Notice we use <code>auto</code> rather than giving the type of
the iterator.</p></li>
</ul>
<p>This code can be simplified still further through the use of a C++11
feature: range-based for loops.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb32-5"><a href="#cb32-5" tabindex="-1"></a><span class="dt">double</span> sum3<span class="op">(</span>doubles xs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-6"><a href="#cb32-6" tabindex="-1"></a>  <span class="dt">double</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> x <span class="op">:</span> xs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-9"><a href="#cb32-9" tabindex="-1"></a>    total <span class="op">+=</span> x<span class="op">;</span></span>
<span id="cb32-10"><a href="#cb32-10" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb32-11"><a href="#cb32-11" tabindex="-1"></a>  <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Iterators also allow us to use the C++ equivalents of the apply
family of functions. For example, we could again rewrite
<code><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum()</a></code> to use the <code>accumulate()</code> function, which
takes a starting and an ending iterator, and adds up all the values in
the vector. The third argument to <code>accumulate</code> gives the
initial value: it’s particularly important because this also determines
the data type that <code>accumulate</code> uses (so we use
<code>0.0</code> and not <code>0</code> so that <code>accumulate</code>
uses a <code>double</code>, not an <code>int</code>.). To use
<code>accumulate()</code> we need to include the
<code>&lt;numeric&gt;</code> header.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a><span class="dt">double</span> sum4<span class="op">(</span>doubles x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>accumulate<span class="op">(</span>x<span class="op">.</span>begin<span class="op">(),</span> x<span class="op">.</span>end<span class="op">(),</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="algorithms">Algorithms<a class="anchor" aria-label="anchor" href="#algorithms"></a>
</h3>
<p>The <code>&lt;algorithm&gt;</code> header provides a large number of
algorithms that work with iterators. A good reference is available at <a href="https://en.cppreference.com/w/cpp/algorithm" class="external-link uri">https://en.cppreference.com/w/cpp/algorithm</a>. For
example, we could write a basic cpp11 version of
<code><a href="https://rdrr.io/r/base/findInterval.html" class="external-link">findInterval()</a></code> that takes two arguments, a vector of values
and a vector of breaks, and locates the bin that each x falls into. This
shows off a few more advanced iterator features. Read the code below and
see if you can figure out how it works.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb34-3"><a href="#cb34-3" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> integers findInterval2<span class="op">(</span>doubles x<span class="op">,</span> doubles breaks<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-6"><a href="#cb34-6" tabindex="-1"></a>  writable<span class="op">::</span>integers out<span class="op">(</span>x<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb34-7"><a href="#cb34-7" tabindex="-1"></a>  <span class="kw">auto</span> out_it <span class="op">=</span> out<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb34-8"><a href="#cb34-8" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;&amp;</span> val <span class="op">:</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-10"><a href="#cb34-10" tabindex="-1"></a>    <span class="kw">auto</span> pos <span class="op">=</span> <span class="bu">std::</span>upper_bound<span class="op">(</span>breaks<span class="op">.</span>begin<span class="op">(),</span> breaks<span class="op">.</span>end<span class="op">(),</span> val<span class="op">);</span></span>
<span id="cb34-11"><a href="#cb34-11" tabindex="-1"></a>    <span class="op">*</span>out_it <span class="op">=</span> <span class="bu">std::</span>distance<span class="op">(</span>breaks<span class="op">.</span>begin<span class="op">(),</span> pos<span class="op">);</span></span>
<span id="cb34-12"><a href="#cb34-12" tabindex="-1"></a>    <span class="op">++</span>out_it<span class="op">;</span></span>
<span id="cb34-13"><a href="#cb34-13" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb34-14"><a href="#cb34-14" tabindex="-1"></a>  <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb34-15"><a href="#cb34-15" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The key points are:</p>
<ul>
<li><p>We step through two iterators (input and output)
simultaneously.</p></li>
<li><p>We can assign into an dereferenced iterator (<code>out_it</code>)
to change the values in <code>out</code>.</p></li>
<li><p><code>upper_bound()</code> returns an iterator. If we wanted the
value of the <code>upper_bound()</code> we could dereference it; to
figure out its location, we use the <code>distance()</code>
function.</p></li>
</ul>
<p>When in doubt, it is generally better to use algorithms from the STL
than hand rolled loops. In <em>Effective STL</em>, Scott Meyers gives
three reasons: efficiency, correctness, and maintainability. Algorithms
from the STL are written by C++ experts to be extremely efficient, and
they have been around for a long time so they are well tested. Using
standard algorithms also makes the intent of your code more clear,
helping to make it more readable and more maintainable.</p>
</div>
<div class="section level3">
<h3 id="data-structures-cpp11">Data structures<a class="anchor" aria-label="anchor" href="#data-structures-cpp11"></a>
</h3>
<p>The STL provides a large set of data structures: <code>array</code>,
<code>bitset</code>, <code>list</code>, <code>forward_list</code>,
<code>map</code>, <code>multimap</code>, <code>multiset</code>,
<code>priority_queue</code>, <code>queue</code>, <code>deque</code>,
<code>set</code>, <code>stack</code>, <code>unordered_map</code>,
<code>unordered_set</code>, <code>unordered_multimap</code>,
<code>unordered_multiset</code>, and <code>vector</code>. The most
important of these data structures are the <code>vector</code>, the
<code>unordered_set</code>, and the <code>unordered_map</code>. We’ll
focus on these three in this section, but using the others is similar:
they just have different performance trade-offs. For example, the
<code>deque</code> (pronounced “deck”) has a very similar interface to
vectors but a different underlying implementation that has different
performance trade-offs. You may want to try it for your problem. A good
reference for STL data structures is <a href="https://en.cppreference.com/w/cpp/container" class="external-link uri">https://en.cppreference.com/w/cpp/container</a> — I
recommend you keep it open while working with the STL.</p>
<p>cpp11 knows how to convert from many STL data structures to their R
equivalents, so you can return them from your functions without
explicitly converting to R data structures.</p>
</div>
<div class="section level3">
<h3 id="vectors-stl">Vectors<a class="anchor" aria-label="anchor" href="#vectors-stl"></a>
</h3>
<p>An STL vector is very similar to an R vector, except that it grows
efficiently. This makes STL vectors appropriate to use when you don’t
know in advance how big the output will be. Vectors are templated, which
means that you need to specify the type of object the vector will
contain when you create it: <code>vector&lt;int&gt;</code>,
<code>vector&lt;bool&gt;</code>, <code>vector&lt;double&gt;</code>,
<code>vector&lt;string&gt;</code>. You can access individual elements of
a vector using the standard <code>[]</code> notation, and you can add a
new element to the end of the vector using <code>.push_back()</code>. If
you have some idea in advance how big the vector will be, you can use
<code>.reserve()</code> to allocate sufficient storage.</p>
<p>The following code implements run length encoding
(<code><a href="https://rdrr.io/r/base/rle.html" class="external-link">rle()</a></code>). It produces two vectors of output: a vector of
values, and a vector <code>lengths</code> giving how many times each
element is repeated. It works by looping through the input vector
<code>x</code> comparing each value to the previous: if it’s the same,
then it increments the last value in <code>lengths</code>; if it’s
different, it adds the value to the end of <code>values</code>, and sets
the corresponding length to 1.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb35-2"><a href="#cb35-2" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" tabindex="-1"></a><span class="kw">namespace</span> writable <span class="op">=</span> cpp11<span class="op">::</span>writable<span class="op">;</span></span>
<span id="cb35-5"><a href="#cb35-5" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb35-7"><a href="#cb35-7" tabindex="-1"></a>list rle_cpp<span class="op">(</span>doubles x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-8"><a href="#cb35-8" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lengths<span class="op">;</span></span>
<span id="cb35-9"><a href="#cb35-9" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> values<span class="op">;</span></span>
<span id="cb35-10"><a href="#cb35-10" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" tabindex="-1"></a>  <span class="co">// Initialise first value</span></span>
<span id="cb35-12"><a href="#cb35-12" tabindex="-1"></a>  <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-13"><a href="#cb35-13" tabindex="-1"></a>  <span class="dt">double</span> prev <span class="op">=</span> x<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb35-14"><a href="#cb35-14" tabindex="-1"></a>  values<span class="op">.</span>push_back<span class="op">(</span>prev<span class="op">);</span></span>
<span id="cb35-15"><a href="#cb35-15" tabindex="-1"></a>  lengths<span class="op">.</span>push_back<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb35-16"><a href="#cb35-16" tabindex="-1"></a></span>
<span id="cb35-17"><a href="#cb35-17" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="kw">auto</span> it <span class="op">=</span> x<span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> it <span class="op">!=</span> x<span class="op">.</span>end<span class="op">();</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-18"><a href="#cb35-18" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>prev <span class="op">==</span> <span class="op">*</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-19"><a href="#cb35-19" tabindex="-1"></a>      lengths<span class="op">[</span>i<span class="op">]++;</span></span>
<span id="cb35-20"><a href="#cb35-20" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb35-21"><a href="#cb35-21" tabindex="-1"></a>      values<span class="op">.</span>push_back<span class="op">(*</span>it<span class="op">);</span></span>
<span id="cb35-22"><a href="#cb35-22" tabindex="-1"></a>      lengths<span class="op">.</span>push_back<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb35-23"><a href="#cb35-23" tabindex="-1"></a>      i<span class="op">++;</span></span>
<span id="cb35-24"><a href="#cb35-24" tabindex="-1"></a>      prev <span class="op">=</span> <span class="op">*</span>it<span class="op">;</span></span>
<span id="cb35-25"><a href="#cb35-25" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb35-26"><a href="#cb35-26" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb35-27"><a href="#cb35-27" tabindex="-1"></a>  <span class="cf">return</span> writable<span class="op">::</span>list<span class="op">({</span></span>
<span id="cb35-28"><a href="#cb35-28" tabindex="-1"></a>    <span class="st">"lengths"</span><span class="op">_nm</span> <span class="op">=</span> lengths<span class="op">,</span></span>
<span id="cb35-29"><a href="#cb35-29" tabindex="-1"></a>    <span class="st">"values"</span><span class="op">_nm</span> <span class="op">=</span> values</span>
<span id="cb35-30"><a href="#cb35-30" tabindex="-1"></a>  <span class="op">});</span></span>
<span id="cb35-31"><a href="#cb35-31" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>(An alternative implementation would be to replace <code>i</code>
with the iterator <code>lengths.rbegin()</code> which always points to
the last element of the vector. You might want to try implementing
that.)</p>
<p>Other methods of a vector are described at <a href="https://en.cppreference.com/w/cpp/container/vector" class="external-link uri">https://en.cppreference.com/w/cpp/container/vector</a>.</p>
</div>
<div class="section level3">
<h3 id="sets">Sets<a class="anchor" aria-label="anchor" href="#sets"></a>
</h3>
<p>Sets maintain a unique set of values, and can efficiently tell if
you’ve seen a value before. They are useful for problems that involve
duplicates or unique values (like <code>unique</code>,
<code>duplicated</code>, or <code>in</code>). C++ provides both ordered
(<code>std::set</code>) and unordered sets
(<code>std::unordered_set</code>), depending on whether or not order
matters for you. Unordered sets can somtimes be much faster (because
they use a hash table internally rather than a tree). Often even if you
need an ordered set, you could consider using an unordered set and then
sorting the output. Benchmarking with your expected dataset is the best
way to determine which is fastest for your data. Like vectors, sets are
templated, so you need to request the appropriate type of set for your
purpose: <code>unordered_set&lt;int&gt;</code>,
<code>unordered_set&lt;bool&gt;</code>, etc. More details are available
at <a href="https://en.cppreference.com/w/cpp/container/set" class="external-link uri">https://en.cppreference.com/w/cpp/container/set</a> and <a href="https://en.cppreference.com/w/cpp/container/unordered_set" class="external-link uri">https://en.cppreference.com/w/cpp/container/unordered_set</a>.</p>
<p>The following function uses an unordered set to implement an
equivalent to <code><a href="https://rdrr.io/r/base/duplicated.html" class="external-link">duplicated()</a></code> for integer vectors. Note the
use of <code>seen.insert(x[i]).second</code>. <code>insert()</code>
returns a pair, the <code>.first</code> value is an iterator that points
to element and the <code>.second</code> value is a Boolean that’s true
if the value was a new addition to the set.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a><span class="kw">namespace</span> writable <span class="op">=</span> cpp11<span class="op">::</span>writable<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a>logicals duplicated_cpp<span class="op">(</span>integers x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a>  <span class="bu">std::</span>unordered_set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> seen<span class="op">;</span></span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> x<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a>  writable<span class="op">::</span>logicals out<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-12"><a href="#cb36-12" tabindex="-1"></a>    out<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">!</span>seen<span class="op">.</span>insert<span class="op">(</span>x<span class="op">[</span>i<span class="op">]).</span>second<span class="op">;</span></span>
<span id="cb36-13"><a href="#cb36-13" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb36-14"><a href="#cb36-14" tabindex="-1"></a>  <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb36-15"><a href="#cb36-15" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<!--- TODO: Add `as_sexp()` support for maps
### Map

A map is similar to a set, but instead of storing presence or absence, it can store additional data.
It's useful for functions like `table()` or `match()` that need to look up a value.
As with sets, there are ordered (`std::map`) and unordered (`std::unordered_map`) versions.
Since maps have a value and a key, you need to specify both types when initialising a map: `map<double, int>`, `unordered_map<int, double>`, and so on.
The following example shows how you could use a `map` to implement `table()` for numeric vectors:


``` cpp
#include <map>
#include "cpp11.hpp"
using namespace cpp11;

[[cpp11::register]]
SEXP table_cpp(doubles x) {
  std::map<double, int> counts;
  int n = x.size();
  for (int i = 0; i < n; i++) {
    counts[x[i]]++;
  }
  return as_sexp(counts);
}
```
!-->
</div>
<div class="section level3">
<h3 id="exercises-2">Exercises<a class="anchor" aria-label="anchor" href="#exercises-2"></a>
</h3>
<p>To practice using the STL algorithms and data structures, implement
the following using R functions in C++, using the hints provided:</p>
<ol style="list-style-type: decimal">
<li><p><code><a href="https://rdrr.io/r/stats/median.html" class="external-link">median.default()</a></code> using
<code>partial_sort</code>.</p></li>
<li><p><code>%in%</code> using <code>unordered_set</code> and the
<code><a href="https://rdrr.io/r/utils/apropos.html" class="external-link">find()</a></code> or <code>count()</code> methods.</p></li>
<li><p><code><a href="https://rdrr.io/r/base/unique.html" class="external-link">unique()</a></code> using an <code>unordered_set</code>
(challenge: do it in one line!).</p></li>
<li><p><code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min()</a></code> using <code>std::min()</code>, or
<code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max()</a></code> using <code>std::max()</code>.</p></li>
<li><p><code><a href="https://rdrr.io/r/base/which.min.html" class="external-link">which.min()</a></code> using <code>min_element</code>, or
<code><a href="https://rdrr.io/r/base/which.min.html" class="external-link">which.max()</a></code> using <code>max_element</code>.</p></li>
<li><p><code><a href="https://rdrr.io/r/base/sets.html" class="external-link">setdiff()</a></code>, <code><a href="https://rdrr.io/r/base/sets.html" class="external-link">union()</a></code>, and
<code><a href="https://rdrr.io/r/base/sets.html" class="external-link">intersect()</a></code> for integers using sorted ranges and
<code>set_union</code>, <code>set_intersection</code> and
<code>set_difference</code>.</p></li>
</ol>
</div>
</div>
<div class="section level2">
<h2 id="case-studies">Case studies<a class="anchor" aria-label="anchor" href="#case-studies"></a>
</h2>
<p>The following case studies illustrate some real life uses of C++ to
replace slow R code.</p>
<div class="section level3">
<h3 id="gibbs-sampler">Gibbs sampler<a class="anchor" aria-label="anchor" href="#gibbs-sampler"></a>
</h3>
<!-- FIXME: needs more context? -->
<p>The following case study updates an example <a href="http://dirk.eddelbuettel.com/blog/2011/07/14/" class="external-link">blogged about</a>
by Dirk Eddelbuettel, illustrating the conversion of a Gibbs sampler in
R to C++. The R and C++ code shown below is very similar (it only took a
few minutes to convert the R version to the C++ version), but runs about
30 times faster on my computer. Dirk’s blog post also shows another way
to make it even faster: using the faster random number generator
functions in GSL (easily accessible from R through the RcppGSL package)
can make it another two to three times faster.</p>
<p>The R code is as follows:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">gibbs_r</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">N</span>, <span class="va">thin</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span>nrow <span class="op">=</span> <span class="va">N</span>, ncol <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span>  <span class="va">x</span> <span class="op">&lt;-</span> <span class="va">y</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">N</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="kw">for</span> <span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">thin</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/GammaDist.html" class="external-link">rgamma</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">3</span>, <span class="va">y</span> <span class="op">*</span> <span class="va">y</span> <span class="op">+</span> <span class="fl">4</span><span class="op">)</span></span>
<span>      <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span> <span class="op">/</span> <span class="op">(</span><span class="va">x</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>, <span class="fl">1</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fl">2</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span>    <span class="va">mat</span><span class="op">[</span><span class="va">i</span>, <span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">y</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="va">mat</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>This is relatively straightforward to convert to C++. We:</p>
<ul>
<li><p>Add type declarations to all variables.</p></li>
<li><p>Use <code>(</code> instead of <code>[</code> to index into the
matrix.</p></li>
<li><p>Include “Rmath.h” and call the functions with
<code>Rf_</code>.</p></li>
</ul>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11/matrix.hpp"</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11/doubles.hpp"</span></span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a><span class="pp">#include </span><span class="im">"Rmath.h"</span></span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a><span class="kw">namespace</span> writable <span class="op">=</span> cpp11<span class="op">::</span>writable<span class="op">;</span></span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span> cpp11<span class="op">::</span>doubles_matrix<span class="op">&lt;&gt;</span> gibbs_cpp<span class="op">(</span><span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> thin<span class="op">)</span> <span class="op">{</span></span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a>  writable<span class="op">::</span>doubles_matrix<span class="op">&lt;&gt;</span> mat<span class="op">(</span>N<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb38-9"><a href="#cb38-9" tabindex="-1"></a>  <span class="dt">double</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-10"><a href="#cb38-10" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb38-11"><a href="#cb38-11" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> thin<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb38-12"><a href="#cb38-12" tabindex="-1"></a>      x <span class="op">=</span> Rf_rgamma<span class="op">(</span><span class="fl">3.</span><span class="op">,</span> <span class="fl">1.</span> <span class="op">/</span> <span class="dt">double</span><span class="op">(</span>y <span class="op">*</span> y <span class="op">+</span> <span class="dv">4</span><span class="op">));</span></span>
<span id="cb38-13"><a href="#cb38-13" tabindex="-1"></a>      y <span class="op">=</span> Rf_rnorm<span class="op">(</span><span class="fl">1.</span> <span class="op">/</span> <span class="op">(</span>x <span class="op">+</span> <span class="fl">1.</span><span class="op">),</span> <span class="fl">1.</span> <span class="op">/</span> sqrt<span class="op">(</span><span class="fl">2.</span> <span class="op">*</span> <span class="op">(</span>x <span class="op">+</span> <span class="fl">1.</span><span class="op">)));</span></span>
<span id="cb38-14"><a href="#cb38-14" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-15"><a href="#cb38-15" tabindex="-1"></a>    mat<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb38-16"><a href="#cb38-16" tabindex="-1"></a>    mat<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb38-17"><a href="#cb38-17" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb38-18"><a href="#cb38-18" tabindex="-1"></a>  <span class="cf">return</span> mat<span class="op">;</span></span>
<span id="cb38-19"><a href="#cb38-19" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Benchmarking the two implementations yields a significant speedup for
running the loops in C++:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">bench</span><span class="fu">::</span><span class="fu"><a href="http://bench.r-lib.org/reference/mark.html" class="external-link">mark</a></span><span class="op">(</span></span>
<span>  r <span class="op">=</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">42</span><span class="op">)</span></span>
<span>    <span class="fu">gibbs_r</span><span class="op">(</span><span class="fl">100</span>, <span class="fl">10</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  cpp <span class="op">=</span> <span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">42</span><span class="op">)</span></span>
<span>    <span class="fu">gibbs_cpp</span><span class="op">(</span><span class="fl">100</span>, <span class="fl">10</span><span class="op">)</span></span>
<span>  <span class="op">}</span>,</span>
<span>  check <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  relative <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 2 × 6</span></span></span>
<span><span class="co">#&gt;   expression   min median `itr/sec` mem_alloc `gc/sec`</span></span>
<span><span class="co">#&gt;   <span style="color: #949494; font-style: italic;">&lt;bch:expr&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">1</span> r           24.0   24.7       1        65.9      <span style="color: #BB0000;">Inf</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">2</span> cpp          1      1        25.3       1        <span style="color: #BB0000;">NaN</span></span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="r-vectorisation-versus-c-vectorisation">R vectorisation versus C++ vectorisation<a class="anchor" aria-label="anchor" href="#r-vectorisation-versus-c-vectorisation"></a>
</h3>
<!-- FIXME: needs more context? -->
<p>This example is adapted from <a href="https://gweissman.github.io/post/rcpp-is-smoking-fast-for-agent-based-models-in-data-frames/" class="external-link">“Rcpp
is smoking fast for agent-based models in data frames”</a>. The
challenge is to predict a model response from three inputs. The basic R
version of the predictor looks like:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vacc1a</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">p</span> <span class="op">&lt;-</span> <span class="fl">0.25</span> <span class="op">+</span> <span class="fl">0.3</span> <span class="op">*</span> <span class="fl">1</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fl">0.04</span> <span class="op">*</span> <span class="va">age</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> <span class="va">ily</span></span>
<span>  <span class="va">p</span> <span class="op">&lt;-</span> <span class="va">p</span> <span class="op">*</span> <span class="kw">if</span> <span class="op">(</span><span class="va">female</span><span class="op">)</span> <span class="fl">1.25</span> <span class="kw">else</span> <span class="fl">0.75</span></span>
<span>  <span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">p</span><span class="op">)</span></span>
<span>  <span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">p</span><span class="op">)</span></span>
<span>  <span class="va">p</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>We want to be able to apply this function to many inputs, so we might
write a vector-input version using a for loop.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vacc1</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">age</span><span class="op">)</span></span>
<span>  <span class="va">out</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">numeric</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_len</a></span><span class="op">(</span><span class="va">n</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">out</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">vacc1a</span><span class="op">(</span><span class="va">age</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="va">female</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, <span class="va">ily</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span></span>
<span>  <span class="op">}</span></span>
<span>  <span class="va">out</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>If you’re familiar with R, you’ll have a gut feeling that this will
be slow, and indeed it is. There are two ways we could attack this
problem. If you have a good R vocabulary, you might immediately see how
to vectorise the function (using <code><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse()</a></code>,
<code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmin()</a></code>, and <code><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmax()</a></code>). Alternatively, we could
rewrite <code>vacc1a()</code> and <code>vacc1()</code> in C++, using our
knowledge that loops and function calls have much lower overhead in
C++.</p>
<p>Either approach is fairly straightforward. In R:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vacc2</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">p</span> <span class="op">&lt;-</span> <span class="fl">0.25</span> <span class="op">+</span> <span class="fl">0.3</span> <span class="op">*</span> <span class="fl">1</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fl">0.04</span> <span class="op">*</span> <span class="va">age</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> <span class="va">ily</span></span>
<span>  <span class="va">p</span> <span class="op">&lt;-</span> <span class="va">p</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span><span class="va">female</span>, <span class="fl">1.25</span>, <span class="fl">0.75</span><span class="op">)</span></span>
<span>  <span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmax</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">p</span><span class="op">)</span></span>
<span>  <span class="va">p</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">pmin</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">p</span><span class="op">)</span></span>
<span>  <span class="va">p</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>(If you’ve worked R a lot you might recognise some potential
bottlenecks in this code: <code>ifelse</code>, <code>pmin</code>, and
<code>pmax</code> are known to be slow, and could be replaced with
<code>p * 0.75 + p * 0.5 * female</code>,
<code>p[p &lt; 0] &lt;- 0</code>, <code>p[p &gt; 1] &lt;- 1</code>. You
might want to try timing those variations.)</p>
<p>Or in C++:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">"cpp11.hpp"</span></span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> cpp11<span class="op">;</span></span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a><span class="kw">namespace</span> writable <span class="op">=</span> cpp11<span class="op">::</span>writable<span class="op">;</span></span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb43-6"><a href="#cb43-6" tabindex="-1"></a><span class="dt">double</span> vacc3a<span class="op">(</span><span class="dt">double</span> age<span class="op">,</span> <span class="dt">bool</span> female<span class="op">,</span> <span class="dt">bool</span> ily<span class="op">){</span></span>
<span id="cb43-7"><a href="#cb43-7" tabindex="-1"></a>  <span class="dt">double</span> p <span class="op">=</span> <span class="fl">0.25</span> <span class="op">+</span> <span class="fl">0.3</span> <span class="op">*</span> <span class="dv">1</span> <span class="op">/</span> <span class="op">(</span><span class="dv">1</span> <span class="op">-</span> exp<span class="op">(</span><span class="fl">0.04</span> <span class="op">*</span> age<span class="op">))</span> <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> ily<span class="op">;</span></span>
<span id="cb43-8"><a href="#cb43-8" tabindex="-1"></a>  p <span class="op">=</span> p <span class="op">*</span> <span class="op">(</span>female <span class="op">?</span> <span class="fl">1.25</span> <span class="op">:</span> <span class="fl">0.75</span><span class="op">);</span></span>
<span id="cb43-9"><a href="#cb43-9" tabindex="-1"></a>  p <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>p<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb43-10"><a href="#cb43-10" tabindex="-1"></a>  p <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>p<span class="op">,</span> <span class="fl">1.0</span><span class="op">);</span></span>
<span id="cb43-11"><a href="#cb43-11" tabindex="-1"></a>  <span class="cf">return</span> p<span class="op">;</span></span>
<span id="cb43-12"><a href="#cb43-12" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb43-13"><a href="#cb43-13" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" tabindex="-1"></a><span class="op">[[</span><span class="at">cpp11</span><span class="op">::</span><span class="at">register</span><span class="op">]]</span></span>
<span id="cb43-15"><a href="#cb43-15" tabindex="-1"></a>doubles vacc3<span class="op">(</span>doubles age<span class="op">,</span> logicals female<span class="op">,</span></span>
<span id="cb43-16"><a href="#cb43-16" tabindex="-1"></a>                    logicals ily<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-17"><a href="#cb43-17" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> age<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb43-18"><a href="#cb43-18" tabindex="-1"></a>  writable<span class="op">::</span>doubles out<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb43-19"><a href="#cb43-19" tabindex="-1"></a>  <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-20"><a href="#cb43-20" tabindex="-1"></a>    out<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> vacc3a<span class="op">(</span>age<span class="op">[</span>i<span class="op">],</span> female<span class="op">[</span>i<span class="op">],</span> ily<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb43-21"><a href="#cb43-21" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb43-22"><a href="#cb43-22" tabindex="-1"></a>  <span class="cf">return</span> out<span class="op">;</span></span>
<span id="cb43-23"><a href="#cb43-23" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We next generate some sample data, and check that all three versions
return the same values:</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fl">1000</span></span>
<span><span class="va">age</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n</span>, mean <span class="op">=</span> <span class="fl">50</span>, sd <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">female</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="cn">T</span>, <span class="cn">F</span><span class="op">)</span>, <span class="va">n</span>, rep <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">ily</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="cn">T</span>, <span class="cn">F</span><span class="op">)</span>, <span class="va">n</span>, prob <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.8</span>, <span class="fl">0.2</span><span class="op">)</span>, rep <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/stopifnot.html" class="external-link">stopifnot</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu">vacc1</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span>, <span class="fu">vacc2</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/all.equal.html" class="external-link">all.equal</a></span><span class="op">(</span><span class="fu">vacc1</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span>, <span class="fu">vacc3</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The original blog post forgot to do this, and introduced a bug in the
C++ version: it used <code>0.004</code> instead of <code>0.04</code>.
Finally, we can benchmark our three approaches:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">bench</span><span class="fu">::</span><span class="fu"><a href="http://bench.r-lib.org/reference/mark.html" class="external-link">mark</a></span><span class="op">(</span></span>
<span>  vacc1 <span class="op">=</span> <span class="fu">vacc1</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span>,</span>
<span>  vacc2 <span class="op">=</span> <span class="fu">vacc2</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span>,</span>
<span>  vacc3 <span class="op">=</span> <span class="fu">vacc3</span><span class="op">(</span><span class="va">age</span>, <span class="va">female</span>, <span class="va">ily</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 3 × 6</span></span></span>
<span><span class="co">#&gt;   expression      min   median `itr/sec` mem_alloc `gc/sec`</span></span>
<span><span class="co">#&gt;   <span style="color: #949494; font-style: italic;">&lt;bch:expr&gt;</span> <span style="color: #949494; font-style: italic;">&lt;bch:tm&gt;</span> <span style="color: #949494; font-style: italic;">&lt;bch:tm&gt;</span>     <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;bch:byt&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">1</span> vacc1        1.46ms    1.5ms      660.    7.86KB     35.8</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">2</span> vacc2       41.69µs   43.7µs    <span style="text-decoration: underline;">21</span>594.  148.56KB     40.0</span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">3</span> vacc3       11.91µs   12.2µs    <span style="text-decoration: underline;">80</span>263.   14.02KB     16.1</span></span></code></pre></div>
<p>Not surprisingly, our original approach with loops is very slow.
Vectorising in R gives a huge speedup, and we can eke out even more
performance (about ten times) with the C++ loop. I was a little
surprised that the C++ was so much faster, but it is because the R
version has to create 11 vectors to store intermediate results, where
the C++ code only needs to create 1.</p>
</div>
</div>
<div class="section level2">
<h2 id="package">Using cpp11 in a package<a class="anchor" aria-label="anchor" href="#package"></a>
</h2>
<p>The same C++ code that is used with <code><a href="../reference/cpp_source.html">cpp_source()</a></code> can
also be bundled into a package. There are several benefits of moving
code from a stand-alone C++ source file to a package:</p>
<ol style="list-style-type: decimal">
<li><p>Your code can be made available to users without C++ development
tools.</p></li>
<li><p>Multiple source files and their dependencies are handled
automatically by the R package build system.</p></li>
<li><p>Packages provide additional infrastructure for testing,
documentation, and consistency.</p></li>
</ol>
<p>To add <code>cpp11</code> to an existing package first put your C++
files in the <code>src/</code> directory of your package.</p>
<p>Then the easiest way to configure everything is to call
<code>usethis::use_cpp11()</code>. Alternatively:</p>
<ul>
<li>
<p>Add this to your <code>DESCRIPTION</code> file:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="fu">LinkingTo</span><span class="kw">:</span><span class="at"> cpp11</span></span></code></pre></div>
</li>
<li>
<p>And add the following <a href="https://roxygen2.r-lib.org/" class="external-link">roxygen</a> directive somewhere in
your package’s R files. (A common location is
<code>R/pkgname-package.R</code>)</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#' @useDynLib pkgname, .registration = TRUE</span></span></code></pre></div>
</li>
<li><p>You’ll then need to run <a href="https://devtools.r-lib.org/reference/document.html" class="external-link"><code>devtools::document()</code></a>
to update your <code>NAMESPACE</code> file to include the
<code>useDynLib</code> statement.</p></li>
</ul>
<p>If you don’t use <code>devtools::load_all()</code>, you’ll also need
to run <code><a href="../reference/cpp_register.html">cpp11::cpp_register()</a></code> before building the package.
This function scans the C++ files for <code>[[cpp11::register]]</code>
attributes and generates the binding code required to make the functions
available in R. Re-run <code><a href="../reference/cpp_register.html">cpp11::cpp_register()</a></code> whenever
functions are added, removed, or have their signatures changed.</p>
</div>
<div class="section level2">
<h2 id="more">Learning more<a class="anchor" aria-label="anchor" href="#more"></a>
</h2>
<p>C++ is a large, complex language that takes years to master. If you
would like to dive deeper or write more complex functions other
resources I’ve found helpful in learning C++ are:</p>
<ul>
<li><p><a href="https://www.aristeia.com/books.html" class="external-link"><em>Effective
C++</em></a> and <a href="https://www.aristeia.com/books.html" class="external-link"><em>Effective
STL</em></a></p></li>
<li><p><a href="http://www.icce.rug.nl/documents/cplusplus/cplusplus.html" class="external-link"><em>C++
Annotations</em></a>, aimed at knowledgeable users of C (or any other
language using a C-like grammar, like Perl or Java) who would like to
know more about, or make the transition to, C++.</p></li>
<li><p><a href="https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/" class="external-link"><em>Algorithm
Libraries</em></a>, which provides a more technical, but still concise,
description of important STL concepts. (Follow the links under
notes.)</p></li>
</ul>
<p>Writing performant code may also require you to rethink your basic
approach: a solid understanding of basic data structures and algorithms
is very helpful here. That’s beyond the scope of this vignette, but I’d
suggest the <a href="https://www.algorist.com/" class="external-link"><em>Algorithm Design
Manual</em></a> MIT’s <a href="https://web.archive.org/web/20200604134756/https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" class="external-link"><em>Introduction
to Algorithms</em></a>, <em>Algorithms</em> by Robert Sedgewick and
Kevin Wayne which has a free <a href="http://algs4.cs.princeton.edu/home/" class="external-link">online textbook</a> and a
matching <a href="https://www.coursera.org/learn/algorithms-part1" class="external-link">Coursera
course</a>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by <a href="https://github.com/DavisVaughan" class="external-link">Davis Vaughan</a>, <a href="http://jimhester.com" class="external-link">Jim Hester</a>, <a href="https://github.com/romainfrancois" class="external-link">Romain François</a>, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

  </div></footer>
</body>
</html>
