#' Generate C function exports and R wrappers for decorated functions
#'
#' Functions decorated with `[[cpp11::export]]` in files ending in `.cc`,
#' `.cpp`, `.h` or `.hpp` will be wrapped in generated code which allows them to be
#' called from R.
#'
#' @param path The path to the package root directory
#' @return The paths to the generated R and C++ source files (in that order).
#' @export
cpp_generate_bindings <- function(path = ".") {
  r_exports <- file.path(path, "R", "cpp11-bindings.R")
  cpp_bindings <- file.path(path, "src", "cpp11-bindings.cpp")
  unlink(c(r_exports, cpp_bindings))

  suppressWarnings(
    all_decorations <- decor::cpp_decorations(path, is_attribute = TRUE)
  )

  if (nrow(all_decorations) == 0) {
    return(invisible(character()))
  }

  exports <- get_exported_functions(all_decorations, "cpp11")

  package <- desc::desc_get("Package", file = file.path(path, "DESCRIPTION"))

  cpp_functions_definitions <- generate_cpp_functions(exports, package)

  r_functions <- generate_r_functions(exports, package)

  dir.create(dirname(r_exports), recursive = TRUE)

  writeLines(con = r_exports, glue::glue('
      # Generated by cpp11: do not edit by hand

      {r_functions}

      '
  ))
  cli::cli_alert_success("generated file {.file {basename(r_exports)}}")

  call_entries <- get_call_entries(path)

  cpp_function_registration <- glue::glue_data(exports, '    {{
    "_cpp11_{name}", (DL_FUNC) &_{package}_{name}, {n_args}}}, ',
    n_args = viapply(exports$args, nrow)
  )

  cpp_function_registration <- glue::glue_collapse(cpp_function_registration, sep  = "\n")

  extra_includes <-  character()
  if (pkg_links_to_rcpp(path)) {
    extra_includes <- c(extra_includes, "#include <Rcpp.h>", "using namespace Rcpp;")
  }

  pkg_types <- file.path(path, "src", paste0(package, "_types.h"))
  if (file.exists(pkg_types)) {
    extra_includes <- c(sprintf('#include "%s"', basename(pkg_types)), extra_includes)
  }

  extra_includes <- paste0(extra_includes, collapse = "\n")

  writeLines(con = cpp_bindings, glue::glue('
      // Generated by cpp11: do not edit by hand

      #include "cpp11/declarations.hpp"
      {extra_includes}

      {cpp_functions_definitions}

      extern "C" {{
      {call_entries}
      }}

      extern "C" void R_init_{package}(DllInfo* dll){{
        R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
        R_useDynamicSymbols(dll, FALSE);
      }}

      ',
      call_entries = glue::glue_collapse(call_entries, "\n")
  ))

  cli::cli_alert_success("generated file {.file {basename(cpp_bindings)}}")

  invisible(c(r_exports, cpp_bindings))
}

utils::globalVariables(c("name", "return_type", "line", "decoration", "context", ".", "functions", "res"))

get_exported_functions <- function(decorations, export_tag) {
  if (NROW(decorations) == 0) {
    return(tibble::tibble(file = character(), line = integer(), decoration = character(), params = list(), context = list(), name = character(), return_type = character(), args = list()))
  }

  out <- decorations[decorations$decoration %in% paste0(export_tag, "::export"), ]
  out$functions <- lapply(out$context, decor::parse_cpp_function, is_attribute = TRUE)
  out <- vctrs::vec_cbind(out, vctrs::vec_rbind(!!!out$functions))

  out <- out[!(names(out) %in% "functions")]
  out$decoration <- sub("::export", "", out$decoration)

  cli::cli_alert_info(glue::glue("{n} functions decorated with [[{tags}::export]]", n = nrow(out), tags = paste0(export_tag, collapse = "|")))

  out
}

generate_cpp_functions <- function(exports, package = "cpp11") {
  exports <- exports[c("name", "return_type", "args", "file", "line", "decoration")]
  exports$real_params <- vcapply(exports$args, glue_collapse_data, "{type} {name}")
  exports$sexp_params <- vcapply(exports$args, glue_collapse_data, "SEXP {name}")
  exports$calls <- mapply(wrap_call, exports$name, exports$return_type, exports$args, SIMPLIFY = TRUE)
  exports$package <- package

  out <- glue::glue_data(exports,
    '
    // {basename(file)}
    {return_type} {name}({real_params});
    extern "C" SEXP _{package}_{name}({sexp_params}) {{
      BEGIN_CPP11
      {calls}
      END_CPP11
    }}
    '
  )
  out <- glue::glue_collapse(out, sep = "\n")
  unclass(out)
}

generate_r_functions <- function(exports, package = "cpp11", use_package = FALSE) {
  if (use_package) {
    package_call <- glue::glue(', PACKAGE = "{package}"')
  } else {
    package_call <- ""
  }

  exports <- exports[c("name", "return_type", "args")]
  exports$package <- package
  exports$package_call <- package_call
  exports$list_params <- vcapply(exports$args, glue_collapse_data, "{name}")
  exports$params <- vcapply(exports$list_params, function(x) if (nzchar(x)) paste0(", ", x) else x)
  is_void <- exports$return_type == "void"
  exports$calls <- ifelse(is_void,
    glue::glue_data(exports, 'invisible(.Call("_{package}_{name}"{params}{package_call}))'),
    glue::glue_data(exports, '.Call("_{package}_{name}"{params}{package_call})')
  )

  out <- glue::glue_data(exports, '
    {name} <- function({list_params}) {{
      {calls}
    }}
    ')
  out <- glue::glue_collapse(out, sep = "\n\n")
  unclass(out)
}

wrap_call <- function(name, return_type, args) {
  call <- glue::glue('{name}({list_params})', list_params = glue_collapse_data(args, "cpp11::unmove(cpp11::as_cpp<{type}>({name}))"))
  if (return_type == "void") {
    unclass(glue::glue("  {call};\n    return R_NilValue;", .trim = FALSE))
  } else {
    unclass(glue::glue("  return cpp11::as_sexp({call});"))
  }
}

get_call_entries <- function(path) {
  con <- textConnection("res", open = "w")

  try(
    tools::package_native_routine_registration_skeleton(path,
      con,
      character_only = FALSE,
      include_declarations = TRUE
    ),
    silent = TRUE
  )

  close(con)

  start <- grep("/* .Call calls */", res, fixed = TRUE)
  end <- grep("};", res, fixed = TRUE)

  if (length(start) == 0) {
    return("")
  }
  res[seq(start, end)]
}

pkg_links_to_rcpp <- function(path) {
  deps <- desc::desc_get_deps(file.path(path, "DESCRIPTION"))

  any(deps$type == "LinkingTo" & deps$package == "Rcpp")
}
